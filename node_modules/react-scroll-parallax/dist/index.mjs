import { EasingPreset, ParallaxController, ScrollAxis, parseValueAndUnit } from "parallax-controller";
import React, { useContext, useEffect, useRef, useState } from "react";

//#region src/utils/removeUndefinedObjectKeys.ts
function removeUndefinedObjectKeys(obj) {
	Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]);
	return obj;
}

//#endregion
//#region src/helpers/getIsolatedParallaxProps.ts
function getIsolatedParallaxProps(props) {
	const { disabled, easing, endScroll, onChange, onEnter, onExit, onProgressChange, opacity, rootMargin, rotate, rotateX, rotateY, rotateZ, scale, scaleX, scaleY, scaleZ, shouldAlwaysCompleteAnimation, shouldDisableScalingTranslations, speed, startScroll, targetElement, translateX, translateY,...rest } = props;
	return {
		parallaxProps: removeUndefinedObjectKeys({
			disabled,
			easing,
			endScroll,
			onChange,
			onEnter,
			onExit,
			onProgressChange,
			opacity,
			rootMargin,
			rotate,
			rotateX,
			rotateY,
			rotateZ,
			scale,
			scaleX,
			scaleY,
			scaleZ,
			shouldAlwaysCompleteAnimation,
			shouldDisableScalingTranslations,
			speed,
			startScroll,
			targetElement,
			translateX,
			translateY
		}),
		rest
	};
}

//#endregion
//#region src/components/Parallax/hooks.ts
function useVerifyController(controller) {
	useEffect(() => {
		const isServer = typeof window === "undefined";
		const isInstance = controller instanceof ParallaxController;
		if (!isServer && !controller && !isInstance) throw new Error("Must wrap your application's <Parallax /> components in a <ParallaxProvider />.");
	}, [controller]);
}

//#endregion
//#region src/context/ParallaxContext.ts
const ParallaxContext = React.createContext(null);

//#endregion
//#region src/hooks/useParallaxController.ts
function useParallaxController() {
	const parallaxController = useContext(ParallaxContext);
	if (typeof window === "undefined") return null;
	if (!parallaxController) throw new Error("Could not find `react-scroll-parallax` context value. Please ensure the component is wrapped in a <ParallaxProvider>");
	return parallaxController;
}

//#endregion
//#region src/hooks/useParallax.ts
function useParallax(props) {
	const controller = useParallaxController();
	const ref = useRef(null);
	const { parallaxProps } = getIsolatedParallaxProps(props);
	useVerifyController(controller);
	const [element, setElement] = useState();
	useEffect(() => {
		let newElement;
		if (ref.current instanceof HTMLElement) {
			const options = {
				el: ref.current,
				props: parallaxProps
			};
			newElement = controller === null || controller === void 0 ? void 0 : controller.createElement(options);
			setElement(newElement);
		} else throw new Error("You must assign the ref returned by the useParallax() hook to an HTML Element.");
		return () => {
			if (newElement) controller === null || controller === void 0 || controller.removeElementById(newElement.id);
		};
	}, []);
	useEffect(() => {
		if (element) if (props.disabled) {
			controller === null || controller === void 0 || controller.resetElementStyles(element);
			controller === null || controller === void 0 || controller.updateElementPropsById(element.id, parallaxProps);
		} else controller === null || controller === void 0 || controller.updateElementPropsById(element.id, parallaxProps);
	}, [
		props.disabled,
		props.easing,
		props.endScroll,
		props.onChange,
		props.onEnter,
		props.onExit,
		props.onProgressChange,
		props.opacity,
		props.rootMargin,
		props.rotate,
		props.rotateX,
		props.rotateY,
		props.rotateZ,
		props.scale,
		props.scaleX,
		props.scaleY,
		props.scaleZ,
		props.shouldAlwaysCompleteAnimation,
		props.shouldDisableScalingTranslations,
		props.speed,
		props.startScroll,
		props.targetElement,
		props.translateX,
		props.translateY
	]);
	return {
		ref,
		controller,
		element
	};
}

//#endregion
//#region src/components/Parallax/Parallax.tsx
function Parallax(props) {
	const { parallaxProps, rest } = getIsolatedParallaxProps(props);
	const { ref } = useParallax(parallaxProps);
	return /* @__PURE__ */ React.createElement("div", {
		ref,
		...rest
	}, props.children);
}

//#endregion
//#region src/components/ParallaxBanner/helpers/getExpandedStyle.ts
const FALLBACK_RECT = { height: 0 };
function getExpandedStyle(layer) {
	if (Array.isArray(layer.translateY)) {
		const translateYStart = parseValueAndUnit(layer.translateY[0]);
		const translateYEnd = parseValueAndUnit(layer.translateY[1]);
		if (translateYStart.unit === "px" && translateYEnd.unit === "px") return {
			top: `${Math.abs(translateYEnd.value) * -1}px`,
			bottom: `${Math.abs(translateYStart.value) * -1}px`
		};
		if (translateYStart.unit === "%" && translateYEnd.unit === "%") {
			var _layer$targetElement$, _layer$targetElement;
			const clientRect = (_layer$targetElement$ = (_layer$targetElement = layer.targetElement) === null || _layer$targetElement === void 0 ? void 0 : _layer$targetElement.getBoundingClientRect()) !== null && _layer$targetElement$ !== void 0 ? _layer$targetElement$ : FALLBACK_RECT;
			const top = Math.abs(clientRect.height * .01 * translateYEnd.value) * -1;
			const bottom = Math.abs(clientRect.height * .01 * translateYStart.value) * -1;
			return {
				top: `${top}px`,
				bottom: `${bottom}px`
			};
		}
	}
	if (layer.speed) {
		const speed = layer.speed || 0;
		const absSpeed = Math.abs(speed) * 10 * -1;
		return {
			top: `${absSpeed}px`,
			bottom: `${absSpeed}px`
		};
	}
	return {};
}

//#endregion
//#region src/components/ParallaxBanner/helpers/getImageStyle.ts
function getImageStyle(layer) {
	return layer.image ? {
		backgroundImage: `url(${layer.image})`,
		backgroundPosition: "center",
		backgroundSize: "cover"
	} : {};
}

//#endregion
//#region src/components/ParallaxBanner/components/ParallaxBannerLayer.tsx
const absoluteStyle = {
	position: "absolute",
	top: 0,
	left: 0,
	right: 0,
	bottom: 0
};
const ParallaxBannerLayer = (props) => {
	const { parallaxProps, rest } = getIsolatedParallaxProps(props);
	const { children, disabled, style, expanded = true, image, testId,...divProps } = rest;
	const imageStyle = getImageStyle(props);
	const expandedStyle = expanded ? getExpandedStyle(props) : {};
	const parallax = useParallax({
		targetElement: props.targetElement,
		shouldDisableScalingTranslations: true,
		...parallaxProps
	});
	return /* @__PURE__ */ React.createElement("div", {
		"data-testid": testId,
		ref: parallax.ref,
		style: {
			...imageStyle,
			...absoluteStyle,
			...expandedStyle,
			...style
		},
		...divProps
	}, rest.children);
};

//#endregion
//#region src/components/ParallaxBanner/ParallaxBanner.tsx
const containerStyle = {
	position: "relative",
	overflow: "hidden",
	width: "100%"
};
const ParallaxBanner = (props) => {
	const [targetElement, setTargetElement] = useState(null);
	const containerRef = useRef(null);
	useEffect(() => {
		setTargetElement(containerRef.current);
	}, []);
	const { disabled: disableAllLayers, style: rootStyle, layers = [],...rootRest } = props;
	function renderLayers() {
		if (targetElement) {
			if (layers && layers.length > 0) return layers.map((layer, i) => /* @__PURE__ */ React.createElement(ParallaxBannerLayer, {
				...layer,
				targetElement,
				key: `layer-${i}`,
				testId: `layer-${i}`
			}));
		}
		return null;
	}
	function renderChildren() {
		if (targetElement) return React.Children.map(props.children, (child) => {
			const item = child;
			if ((item === null || item === void 0 ? void 0 : item.type) === ParallaxBannerLayer) return React.cloneElement(item, { targetElement });
			return child;
		});
		return null;
	}
	return /* @__PURE__ */ React.createElement("div", {
		ref: containerRef,
		style: {
			...containerStyle,
			...rootStyle
		},
		...rootRest
	}, renderLayers(), renderChildren());
};

//#endregion
//#region src/components/ParallaxProvider/helpers.ts
const createController = (options) => {
	if (!(typeof window === "undefined")) return ParallaxController.init(options);
	return null;
};

//#endregion
//#region src/components/ParallaxProvider/ParallaxProvider.tsx
function ParallaxProvider(props) {
	const controller = useRef(null);
	if (!controller.current) controller.current = createController({
		scrollAxis: props.scrollAxis || ScrollAxis.vertical,
		scrollContainer: props.scrollContainer,
		disabled: props.isDisabled
	});
	useEffect(() => {
		if (props.scrollContainer && controller.current) controller.current.updateScrollContainer(props.scrollContainer);
	}, [props.scrollContainer]);
	useEffect(() => {
		if (props.isDisabled && controller.current) controller.current.disableParallaxController();
		if (!props.isDisabled && controller.current) controller.current.enableParallaxController();
	}, [props.isDisabled]);
	useEffect(() => {
		return () => {
			var _controller$current;
			controller === null || controller === void 0 || (_controller$current = controller.current) === null || _controller$current === void 0 || _controller$current.destroy();
		};
	}, []);
	return /* @__PURE__ */ React.createElement(ParallaxContext.Provider, { value: controller.current }, props.children);
}

//#endregion
export { EasingPreset, Parallax, ParallaxBanner, ParallaxBannerLayer, ParallaxContext, ParallaxProvider, useParallax, useParallaxController };
//# sourceMappingURL=index.mjs.map